-- Component that blocks light, contains functions to generate shadow volumes
local BlocksLight = {
    __name = "BlocksLight"
    -- The shadowmesh is autogenerated by init if its not specified
    --shadowmesh = {
        --Vector( -32, -32 ),
        --Vector( -32, 32 ),
        --Vector( 32, 32 ),
        --Vector( 32, -32 )
    --}
}

function BlocksLight:getShadowVolume( lightpos, lightradius )
    --TODO: verify lightpos is an actual vector
    local volumeverticies = {}
    local max = table.maxn( self.shadowmesh )
    -- Get a list of backfaces
    for i,v in pairs( self.shadowmesh ) do
        local v1 = self:getPos() + v[1]:rotated( self:getRot() )
        local v2 = self:getPos() + v[2]:rotated( self:getRot() )

        -- The dot product of the face's normal with the vector
        -- from the face to the light distiguishes if the face is
        -- facing the light.
        local facenormal = v2:angleTo( v1 ) - math.pi/2
        local facecenter = ( v1 + v2 ) / 2
        local facetolight = lightpos - facecenter

        local faceunitvector = Vector( math.cos( facenormal ), math.sin( facenormal ) )
        local facing = faceunitvector * facetolight > 0
        if not facing then
            local lightangle = lightpos:angleTo( v1 )
            local v1extrude = v1 - Vector( math.cos( lightangle ), math.sin( lightangle ) ) * lightradius
            lightangle = lightpos:angleTo( v2 )
            local v2extrude = v2 - Vector( math.cos( lightangle ), math.sin( lightangle ) ) * lightradius
            table.insert( volumeverticies, { v1.x, v1.y, 0, 0, 255, 255, 255 } )
            table.insert( volumeverticies, { v1extrude.x, v1extrude.y, 0, 0, 255, 255, 255 } )
            table.insert( volumeverticies, { v2.x, v2.y, 0, 0, 255, 255, 255 } )

            table.insert( volumeverticies, { v2extrude.x, v2extrude.y, 0, 0, 255, 255, 255 } )
            table.insert( volumeverticies, { v2.x, v2.y, 0, 0, 255, 255, 255 } )
            table.insert( volumeverticies, { v1extrude.x, v1extrude.y, 0, 0, 255, 255, 255 } )
        end
    end
    return volumeverticies
end

function BlocksLight:setPos( x, y )
    Renderer:updateLights()
end

function BlocksLight:setRot( rot )
    Renderer:updateLights()
end

-- UNUSED
-- function BlocksLight:setDrawable( obj )
    -- local w = obj:getWidth() / 2
    -- local h = obj:getHeight() / 2
    -- self.shadowmesh = {
        -- Vector( -w, -h ),
        -- Vector( -w, h ),
        -- Vector( w, h ),
        -- Vector( w, -h )
    -- }
-- end

function BlocksLight:init()
    if self.drawable ~= nil and self.shadowmesh == nil then
        local w = self.drawable:getWidth() / 2
        local h = self.drawable:getHeight() / 2
        self.shadowmesh = {
            { Vector( -w, -h ), Vector( w, -h ) },
            { Vector( w, -h ), Vector( w, h ) },
            { Vector( w, h ), Vector( -w, h ) },
            { Vector( -w, h ), Vector( -w, -h ) }
        }
    end
    Renderer:updateLights()
end

function BlocksLight:deinit()
    Renderer:updateLights()
end

return BlocksLight
